cstring:
  to clear: charray[0] = '\0';
  const char* always has a sentinel character

strstr:
  #include no need
    char* strstr(char* str, const char* target);
    const char* strstr(const char* str, const char* target);
    //returns *p to 1st occurrence in str1 of str2, else null *p

getline:
  #include<istream> or #include<fstream>
    istream.getline(char*, int size)
    istream.getline(char*, int size, char delim)

strtok:
  #include<cstring>
    char* strtok(char*, const char* delims);
  example:
    for(char* p=strtok(str,".,"); p!=NULL; p=strtok(NULL,".,"))
    //look out for that null at the end

strcpy:
  #include<cstring>
    char* strcpy(char* dest, const char* source);

strcat:
  #include<cstring>
    char* strcat(char* dest, const char* source)

strcmp:
  #include<cstring>
    int strcmp(const char*, const char*);
    //returns 0 if identical
    //returns >0 if 1st char to not match has 
    //greater value in charray1 vs charray2
    //and vice versa

strncmp:
  #include<cstring>
    int strncmp(const char*, const char*, int n);
    //strcmp() on first n characters of both strings
    //C doesn't support overloading

vector:
  #include<vector>
    typedef vector<Class> Vec;
    typedef vector<Class>::iterator VecIt;
  append_1_element
    vecobj.push_back(Class element);
  insert
    vecobj.insert();
  search
    vecobj.find(vecobj.begin(), vecobj.end(), Class element);
    //returns VecIt pointing to element found

string
  #include<string>
    append_char
      void push_back(char ch);

carrays:
const char* is same as char const*
char* const is a constant pointer to a char
const char* const is a constant pointer to a const char


SILLY STUFF:
- makefile syntax (don't forget anything)
- _.cpp doesn't need #include"_.h" unless a function in .cpp is called before having been defined
- 
